import numpy as np

def biased_competition_model(sensory_input, top_down_signal, alpha=0.5):
    attended_response = sensory_input + alpha * top_down_signal
    return attended_response

def oscillatory_binding_model(phases, frequencies, coupling_matrix):
    dt = 0.01
    for _ in range(1000):
        phase_differences = np.subtract.outer(phases, phases)
        dphases = frequencies + np.sum(coupling_matrix * np.sin(phase_differences), axis=1)
        phases += dphases * dt
    return phases